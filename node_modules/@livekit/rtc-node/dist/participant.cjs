"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var participant_exports = {};
__export(participant_exports, {
  LocalParticipant: () => LocalParticipant,
  Participant: () => Participant,
  RemoteParticipant: () => RemoteParticipant
});
module.exports = __toCommonJS(participant_exports);
var import_protobuf = require("@bufbuild/protobuf");
var import_ffi_client = require("./ffi_client.cjs");
var import_room_pb = require("./proto/room_pb.cjs");
var import_room_pb2 = require("./proto/room_pb.cjs");
var import_rpc_pb = require("./proto/rpc_pb.cjs");
var import_rpc = require("./rpc.cjs");
var import_track_publication = require("./track_publication.cjs");
class Participant {
  constructor(owned_info) {
    this.trackPublications = /* @__PURE__ */ new Map();
    this.info = owned_info.info;
    this.ffi_handle = new import_ffi_client.FfiHandle(owned_info.handle.id);
  }
  get sid() {
    return this.info.sid;
  }
  get name() {
    return this.info.name;
  }
  get identity() {
    return this.info.identity;
  }
  get metadata() {
    return this.info.metadata;
  }
  get attributes() {
    return this.info.attributes;
  }
  get kind() {
    return this.info.kind;
  }
}
class LocalParticipant extends Participant {
  constructor() {
    super(...arguments);
    this.rpcHandlers = /* @__PURE__ */ new Map();
    this.trackPublications = /* @__PURE__ */ new Map();
  }
  async publishData(data, options) {
    const req = (0, import_protobuf.create)(import_room_pb.PublishDataRequestSchema, {
      localParticipantHandle: this.ffi_handle.handle,
      dataPtr: import_ffi_client.FfiClient.instance.retrievePtr(data),
      dataLen: BigInt(data.byteLength),
      reliable: options.reliable,
      topic: options.topic,
      destinationIdentities: options.destination_identities
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "publishData", value: req }
    });
    const cb = await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "publishData" && ev.message.value.asyncId == res.asyncId;
    });
    if (cb.error) {
      throw new Error(cb.error);
    }
  }
  async publishDtmf(code, digit) {
    const req = (0, import_protobuf.create)(import_room_pb.PublishSipDtmfRequestSchema, {
      localParticipantHandle: this.ffi_handle.handle,
      code,
      digit
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "publishSipDtmf", value: req }
    });
    const cb = await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "publishSipDtmf" && ev.message.value.asyncId == res.asyncId;
    });
    if (cb.error) {
      throw new Error(cb.error);
    }
  }
  async publishTranscription(transcription) {
    const req = (0, import_protobuf.create)(import_room_pb.PublishTranscriptionRequestSchema, {
      localParticipantHandle: this.ffi_handle.handle,
      participantIdentity: transcription.participantIdentity,
      segments: transcription.segments.map(
        (s) => (0, import_protobuf.create)(import_room_pb2.TranscriptionSegmentSchema, {
          id: s.id,
          text: s.text,
          startTime: s.startTime,
          endTime: s.endTime,
          final: s.final,
          language: s.language
        })
      ),
      trackId: transcription.trackSid
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "publishTranscription", value: req }
    });
    const cb = await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "publishTranscription" && ev.message.value.asyncId == res.asyncId;
    });
    if (cb.error) {
      throw new Error(cb.error);
    }
  }
  async updateMetadata(metadata) {
    const req = (0, import_protobuf.create)(import_room_pb.SetLocalMetadataRequestSchema, {
      localParticipantHandle: this.ffi_handle.handle,
      metadata
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "setLocalMetadata", value: req }
    });
    await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "setLocalMetadata" && ev.message.value.asyncId == res.asyncId;
    });
  }
  /**
   * Sends a chat message to participants in the room
   *
   * @param text - The text content of the chat message.
   * @param destinationIdentities - An optional array of recipient identities to whom the message will be sent. If omitted, the message is broadcast to all participants.
   * @param senderIdentity - An optional identity of the sender. If omitted, the default sender identity is used.
   *
   */
  async sendChatMessage(text, destinationIdentities, senderIdentity) {
    const req = (0, import_protobuf.create)(import_room_pb.SendChatMessageRequestSchema, {
      localParticipantHandle: this.ffi_handle.handle,
      message: text,
      destinationIdentities,
      senderIdentity
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "sendChatMessage", value: req }
    });
    const cb = await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "chatMessage" && ev.message.value.asyncId == res.asyncId;
    });
    if (cb.message.case !== "chatMessage") {
      throw new Error(cb.message.value ?? "Unknown Error");
    }
    const { id, timestamp, editTimestamp, message } = cb.message.value;
    return { id, timestamp: Number(timestamp), editTimestamp: Number(editTimestamp), message };
  }
  /**
   * @experimental
   */
  async editChatMessage(editText, originalMessage, destinationIdentities, senderIdentity) {
    const req = (0, import_protobuf.create)(import_room_pb.EditChatMessageRequestSchema, {
      localParticipantHandle: this.ffi_handle.handle,
      editText,
      originalMessage: (0, import_protobuf.create)(import_room_pb.ChatMessageSchema, {
        ...originalMessage,
        timestamp: BigInt(originalMessage.timestamp),
        editTimestamp: originalMessage.editTimestamp ? BigInt(originalMessage.editTimestamp) : void 0
      }),
      destinationIdentities,
      senderIdentity
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "editChatMessage", value: req }
    });
    const cb = await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "chatMessage" && ev.message.value.asyncId == res.asyncId;
    });
    if (cb.message.case !== "chatMessage") {
      throw new Error(cb.message.value ?? "Unknown Error");
    }
    const { id, timestamp, editTimestamp, message } = cb.message.value;
    return { id, timestamp: Number(timestamp), editTimestamp: Number(editTimestamp), message };
  }
  async updateName(name) {
    const req = (0, import_protobuf.create)(import_room_pb.SetLocalNameRequestSchema, {
      localParticipantHandle: this.ffi_handle.handle,
      name
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "setLocalName", value: req }
    });
    await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "setLocalName" && ev.message.value.asyncId == res.asyncId;
    });
  }
  async setAttributes(attributes) {
    const req = (0, import_protobuf.create)(import_room_pb.SetLocalAttributesRequestSchema, {
      localParticipantHandle: this.ffi_handle.handle,
      attributes: Array.from(Object.entries(attributes)).map(([key, value]) => {
        return { key, value };
      })
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "setLocalAttributes", value: req }
    });
    await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "setLocalAttributes" && ev.message.value.asyncId == res.asyncId;
    });
  }
  async publishTrack(track, options) {
    const req = (0, import_protobuf.create)(import_room_pb.PublishTrackRequestSchema, {
      localParticipantHandle: this.ffi_handle.handle,
      trackHandle: track.ffi_handle.handle,
      options
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "publishTrack", value: req }
    });
    const cb = await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "publishTrack" && ev.message.value.asyncId == res.asyncId;
    });
    if (cb.message.case !== "publication") {
      throw new Error(cb.message.value ?? "Unknown Error");
    }
    const track_publication = new import_track_publication.LocalTrackPublication(cb.message.value);
    track_publication.track = track;
    this.trackPublications.set(track_publication.sid, track_publication);
    return track_publication;
  }
  async unpublishTrack(trackSid) {
    const req = (0, import_protobuf.create)(import_room_pb.UnpublishTrackRequestSchema, {
      localParticipantHandle: this.ffi_handle.handle,
      trackSid
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "unpublishTrack", value: req }
    });
    const cb = await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "unpublishTrack" && ev.message.value.asyncId == res.asyncId;
    });
    if (cb.error) {
      throw new Error(cb.error);
    }
    const pub = this.trackPublications.get(trackSid);
    if (pub) {
      pub.track = void 0;
    }
    this.trackPublications.delete(trackSid);
  }
  /**
   * Initiate an RPC call to a remote participant.
   * @param params - Parameters for initiating the RPC call, see {@link PerformRpcParams}
   * @returns A promise that resolves with the response payload or rejects with an error.
   * @throws Error on failure. Details in `message`.
   */
  async performRpc({
    destinationIdentity,
    method,
    payload,
    responseTimeout
  }) {
    const req = (0, import_protobuf.create)(import_rpc_pb.PerformRpcRequestSchema, {
      localParticipantHandle: this.ffi_handle.handle,
      destinationIdentity,
      method,
      payload,
      responseTimeoutMs: responseTimeout
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "performRpc", value: req }
    });
    const cb = await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case === "performRpc" && ev.message.value.asyncId === res.asyncId;
    });
    if (cb.error) {
      throw import_rpc.RpcError.fromProto(cb.error);
    }
    return cb.payload;
  }
  /**
   * Establishes the participant as a receiver for calls of the specified RPC method.
   * Will overwrite any existing callback for the same method.
   *
   * @param method - The name of the indicated RPC method
   * @param handler - Will be invoked when an RPC request for this method is received
   * @returns A promise that resolves when the method is successfully registered
   *
   * @example
   * ```typescript
   * room.localParticipant?.registerRpcMethod(
   *   'greet',
   *   async (data: RpcInvocationData) => {
   *     console.log(`Received greeting from ${data.callerIdentity}: ${data.payload}`);
   *     return `Hello, ${data.callerIdentity}!`;
   *   }
   * );
   * ```
   *
   * See {@link RpcInvocationData} for more details on invocation params.
   *
   * The handler should return a Promise that resolves to a string.
   * If unable to respond within `responseTimeout`, the request will result in an error on the caller's side.
   *
   * You may throw errors of type `RpcError` with a string `message` in the handler,
   * and they will be received on the caller's side with the message intact.
   * Other errors thrown in your handler will not be transmitted as-is, and will instead arrive to the caller as `1500` ("Application Error").
   */
  registerRpcMethod(method, handler) {
    this.rpcHandlers.set(method, handler);
    const req = (0, import_protobuf.create)(import_rpc_pb.RegisterRpcMethodRequestSchema, {
      localParticipantHandle: this.ffi_handle.handle,
      method
    });
    import_ffi_client.FfiClient.instance.request({
      message: { case: "registerRpcMethod", value: req }
    });
  }
  /**
   * Unregisters a previously registered RPC method.
   *
   * @param method - The name of the RPC method to unregister
   */
  unregisterRpcMethod(method) {
    this.rpcHandlers.delete(method);
    const req = (0, import_protobuf.create)(import_rpc_pb.UnregisterRpcMethodRequestSchema, {
      localParticipantHandle: this.ffi_handle.handle,
      method
    });
    import_ffi_client.FfiClient.instance.request({
      message: { case: "unregisterRpcMethod", value: req }
    });
  }
  /** @internal */
  async handleRpcMethodInvocation(invocationId, method, requestId, callerIdentity, payload, responseTimeout) {
    let responseError = null;
    let responsePayload = null;
    const handler = this.rpcHandlers.get(method);
    if (!handler) {
      responseError = import_rpc.RpcError.builtIn("UNSUPPORTED_METHOD");
    } else {
      try {
        responsePayload = await handler({ requestId, callerIdentity, payload, responseTimeout });
      } catch (error) {
        if (error instanceof import_rpc.RpcError) {
          responseError = error;
        } else {
          console.warn(
            `Uncaught error returned by RPC handler for ${method}. Returning APPLICATION_ERROR instead.`,
            error
          );
          responseError = import_rpc.RpcError.builtIn("APPLICATION_ERROR");
        }
      }
    }
    const req = (0, import_protobuf.create)(import_rpc_pb.RpcMethodInvocationResponseRequestSchema, {
      localParticipantHandle: this.ffi_handle.handle,
      invocationId,
      error: responseError ? responseError.toProto() : void 0,
      payload: responsePayload ?? void 0
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: { case: "rpcMethodInvocationResponse", value: req }
    });
    if (res.error) {
      console.warn(`error sending rpc method invocation response: ${res.error}`);
    }
  }
}
class RemoteParticipant extends Participant {
  constructor(owned_info) {
    super(owned_info);
    this.trackPublications = /* @__PURE__ */ new Map();
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  LocalParticipant,
  Participant,
  RemoteParticipant
});
//# sourceMappingURL=participant.cjs.map