import { FfiHandle } from './napi/native.d.cjs';
import { TrackPublishOptions } from './proto/room_pb.cjs';
import { ParticipantInfo, OwnedParticipant, ParticipantKind } from './proto/participant_pb.cjs';
import { PerformRpcParams, RpcInvocationData } from './rpc.cjs';
import { LocalTrack } from './track.cjs';
import { TrackPublication, LocalTrackPublication, RemoteTrackPublication } from './track_publication.cjs';
import { Transcription } from './transcription.cjs';
import { ChatMessage } from './types.cjs';
import '@bufbuild/protobuf/codegenv1';
import './proto/e2ee_pb.cjs';
import '@bufbuild/protobuf';
import './proto/handle_pb.cjs';
import './proto/track_pb.cjs';
import './proto/stats_pb.cjs';
import './proto/video_frame_pb.cjs';
import './proto/rpc_pb.cjs';
import './audio_source.cjs';
import './audio_frame.cjs';
import './proto/audio_frame_pb.cjs';
import './video_source.cjs';
import './video_frame.cjs';

declare abstract class Participant {
    /** @internal */
    info: ParticipantInfo;
    /** @internal */
    ffi_handle: FfiHandle;
    trackPublications: Map<string, TrackPublication>;
    constructor(owned_info: OwnedParticipant);
    get sid(): string;
    get name(): string;
    get identity(): string;
    get metadata(): string;
    get attributes(): Record<string, string>;
    get kind(): ParticipantKind;
}
type DataPublishOptions = {
    /**
     * whether to send this as reliable or lossy.
     * For data that you need delivery guarantee (such as chat messages), use Reliable.
     * For data that should arrive as quickly as possible, but you are ok with dropped
     * packets, use Lossy.
     */
    reliable?: boolean;
    /**
     * the identities of participants who will receive the message, will be sent to every one if empty
     */
    destination_identities?: string[];
    /** the topic under which the message gets published */
    topic?: string;
};
declare class LocalParticipant extends Participant {
    private rpcHandlers;
    trackPublications: Map<string, LocalTrackPublication>;
    publishData(data: Uint8Array, options: DataPublishOptions): Promise<void>;
    publishDtmf(code: number, digit: string): Promise<void>;
    publishTranscription(transcription: Transcription): Promise<void>;
    updateMetadata(metadata: string): Promise<void>;
    /**
     * Sends a chat message to participants in the room
     *
     * @param text - The text content of the chat message.
     * @param destinationIdentities - An optional array of recipient identities to whom the message will be sent. If omitted, the message is broadcast to all participants.
     * @param senderIdentity - An optional identity of the sender. If omitted, the default sender identity is used.
     *
     */
    sendChatMessage(text: string, destinationIdentities?: Array<string>, senderIdentity?: string): Promise<ChatMessage>;
    /**
     * @experimental
     */
    editChatMessage(editText: string, originalMessage: ChatMessage, destinationIdentities?: Array<string>, senderIdentity?: string): Promise<ChatMessage>;
    updateName(name: string): Promise<void>;
    setAttributes(attributes: Record<string, string>): Promise<void>;
    publishTrack(track: LocalTrack, options: TrackPublishOptions): Promise<LocalTrackPublication>;
    unpublishTrack(trackSid: string): Promise<void>;
    /**
     * Initiate an RPC call to a remote participant.
     * @param params - Parameters for initiating the RPC call, see {@link PerformRpcParams}
     * @returns A promise that resolves with the response payload or rejects with an error.
     * @throws Error on failure. Details in `message`.
     */
    performRpc({ destinationIdentity, method, payload, responseTimeout, }: PerformRpcParams): Promise<string>;
    /**
     * Establishes the participant as a receiver for calls of the specified RPC method.
     * Will overwrite any existing callback for the same method.
     *
     * @param method - The name of the indicated RPC method
     * @param handler - Will be invoked when an RPC request for this method is received
     * @returns A promise that resolves when the method is successfully registered
     *
     * @example
     * ```typescript
     * room.localParticipant?.registerRpcMethod(
     *   'greet',
     *   async (data: RpcInvocationData) => {
     *     console.log(`Received greeting from ${data.callerIdentity}: ${data.payload}`);
     *     return `Hello, ${data.callerIdentity}!`;
     *   }
     * );
     * ```
     *
     * See {@link RpcInvocationData} for more details on invocation params.
     *
     * The handler should return a Promise that resolves to a string.
     * If unable to respond within `responseTimeout`, the request will result in an error on the caller's side.
     *
     * You may throw errors of type `RpcError` with a string `message` in the handler,
     * and they will be received on the caller's side with the message intact.
     * Other errors thrown in your handler will not be transmitted as-is, and will instead arrive to the caller as `1500` ("Application Error").
     */
    registerRpcMethod(method: string, handler: (data: RpcInvocationData) => Promise<string>): void;
    /**
     * Unregisters a previously registered RPC method.
     *
     * @param method - The name of the RPC method to unregister
     */
    unregisterRpcMethod(method: string): void;
    /** @internal */
    handleRpcMethodInvocation(invocationId: bigint, method: string, requestId: string, callerIdentity: string, payload: string, responseTimeout: number): Promise<void>;
}
declare class RemoteParticipant extends Participant {
    trackPublications: Map<string, RemoteTrackPublication>;
    constructor(owned_info: OwnedParticipant);
}

export { type DataPublishOptions, LocalParticipant, Participant, RemoteParticipant };
